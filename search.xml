<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前端js面试题</title>
      <link href="/2023/05/23/js%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2023/05/23/js%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>继续整理，本篇以js内容为主，如需其他，请阅读其他文章。</p><h2 id="js数据类型"><a href="#js数据类型" class="headerlink" title="js数据类型"></a>js数据类型</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul><li>Number 数字类型</li><li>String 字符串类型</li><li>Boolean 布尔值</li><li>Null 空值</li><li>Undefined 未定义</li><li>Object 对象</li><li>Array 数组</li><li>Symbol 表示唯一的、不可变的值，用于创建对象的唯一标识符。Symbol 在 ES6 中引入。</li><li>BigInt 数值太大的数字类型</li></ul><h3 id="特殊数据类型"><a href="#特殊数据类型" class="headerlink" title="特殊数据类型"></a>特殊数据类型</h3><ul><li>Function 函数数据类型</li></ul><h2 id="检测数据类型的方式"><a href="#检测数据类型的方式" class="headerlink" title="检测数据类型的方式"></a>检测数据类型的方式</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><ul><li>typeof 是一个一元操作符，用于获取一个值的类型。它返回一个表示数据类型的字符串。</li><li>返回值为字符串。</li><li>可以准确的判断出基本数据类型和Funtcion，其他均为object。<br>  <font color=#00FFFF>例：</font>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">42</span>; <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&quot;Hello&quot;</span>; <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">// &quot;boolean&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">// &quot;object&quot; (注意这是一个历史遗留问题，null 被错误地判断为对象)</span></span><br><span class="line"><span class="keyword">typeof</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;; <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;; <span class="comment">// &quot;function&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><ul><li>instanceof 操作符用于检查一个对象是否是某个构造函数创建的实例。它可以判断对象是否属于特定的类型或其子类型。</li><li>返回值为Boolean值。</li><li>对于原始值（如数字、字符串、布尔值等），使用 instanceof 操作符会返回 false，因为原始值不是对象。</li><li>而对于对象类型（如数组、函数、对象等），instanceof 可以判断其是否属于特定类型或其子类型。<br>  <font color=#00FFFF>例：</font>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="number">42</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num <span class="keyword">instanceof</span> <span class="title class_">Number</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str <span class="keyword">instanceof</span> <span class="title class_">String</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bool = <span class="literal">true</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bool <span class="keyword">instanceof</span> <span class="title class_">Boolean</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> undef = <span class="literal">undefined</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(undef <span class="keyword">instanceof</span> <span class="title class_">Undefined</span>); <span class="comment">// 报错，Undefined 不是一个构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nul = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nul <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> func = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(func <span class="keyword">instanceof</span> <span class="title class_">Function</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="手写实现instanceof"><a href="#手写实现instanceof" class="headerlink" title="手写实现instanceof"></a>手写实现instanceof</h3>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceof</span>(<span class="params">obj, constructor</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || obj === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> prototype = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (prototype !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prototype === constructor.<span class="property"><span class="keyword">prototype</span></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    prototype = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(prototype);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray"></a>Array.isArray</h3><ul><li>Array.isArray() 是一个静态方法，用于检查一个值是否是数组类型。</li><li>返回值为布尔值。<br>  <font color=#00FFFF>例：</font>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString()"></a>Object.prototype.toString()</h3><ul><li>Object.prototype.toString() 是 Object 原型上的方法</li><li>返回值为对象类型的字符串<br>  <font color=#00FFFF>例：</font>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">42</span>); <span class="comment">// &quot;[object Number]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// &quot;[object String]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">true</span>); <span class="comment">// &quot;[object Boolean]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">undefined</span>); <span class="comment">// &quot;[object Undefined]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">null</span>); <span class="comment">// &quot;[object Null]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// &quot;[object Array]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(&#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;); <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;); <span class="comment">// &quot;[object Function]&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="var-let-const"><a href="#var-let-const" class="headerlink" title="var, let, const"></a>var, let, const</h2><h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><ul><li>函数作用域：var 声明的变量具有函数作用域，即变量的作用范围限定在声明它的函数内部。</li><li>变量提升：使用 var 声明的变量会发生变量提升，即在函数内部，无论在哪里声明变量，变量声明都会被提升到函数的顶部。</li></ul><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><ul><li>块级作用域：let 声明的变量具有块级作用域，即变量的作用范围限定在当前代码块内部（如 {} 中）。</li><li>没有变量提升：使用 let 声明的变量不会发生变量提升，只有在变量声明之后才能访问。</li></ul><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><ul><li>块级作用域：const 声明的变量具有块级作用域。</li><li>常量赋值：const 声明的变量必须在声明时进行初始化，并且不能再次赋值。它的值是不可变的。</li></ul><h2 id="作用域-amp-amp-作用域链"><a href="#作用域-amp-amp-作用域链" class="headerlink" title="作用域&amp;&amp;作用域链"></a>作用域&amp;&amp;作用域链</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul><li>全局作用域： 全局作用域是在整个 JavaScript 程序中可访问的最外层作用域。在全局作用域中声明的变量和函数可以被程序中的任何部分访问。</li><li>函数作用域： 函数作用域是在函数内部声明的变量的作用域范围。函数作用域中的变量只能在函数内部访问，而无法在函数外部或其他函数中访问。</li><li>块级作用域： 块级作用域是在代码块（如 if、for、while 语句等）中声明的变量的作用域范围。块级作用域中的变量只能在该代码块内部访问，而在代码块外部是不可见的。<br>  <font color=red>注：</font> 如果一个变量没有声明直接使用：<ul><li>严格模式下：报错（ReferenceError: x is not defined）</li><li>非严格模式下：JavaScript 引擎将隐式地将该变量视为<font color=red>全局变量</font>，并返回其值为 undefined</li></ul></li></ul><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><ul><li>作用域链（Scope Chain）是 JavaScript 中用于查找变量的机制。当代码中引用一个变量时，JavaScript 引擎会按照特定的规则沿着作用域链进行变量查找，直到找到匹配的变量或达到最外层的全局作用域。</li><li>作用域链的构建是根据变量的词法环境（Lexical Environment）进行的。每当创建一个新的执行上下文（函数执行上下文或全局执行上下文），就会创建一个新的词法环境，并将其与当前的词法环境形成一个链式结构。</li><li>当访问一个变量时，JavaScript 引擎首先在当前的词法环境中查找该变量，如果找到了就使用它。如果没有找到，则继续沿着作用域链向上查找，直到找到匹配的变量或到达全局作用域。</li><li>如果在最外层的全局作用域中仍然没有找到该变量，那么会抛出一个引用错误。</li></ul><h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><h3 id="标记清楚法"><a href="#标记清楚法" class="headerlink" title="标记清楚法"></a>标记清楚法</h3><ul><li>在标记阶段，垃圾回收器从根对象开始遍历所有可访问的对象，并标记活动对象。</li><li>在清除阶段，垃圾回收器清除所有未被标记的对象，释放它们占用的内存空间。</li></ul><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><ul><li>每当一个对象被引用时，引用计数加一；</li><li>当一个对象的引用被删除或覆盖时，引用计数减一。</li><li>当引用计数为零时，即没有任何引用指向该对象，该对象被判定为垃圾并被回收。<br>  <font color=red>注：</font>引用计数方法无法解决循环引用的问题，即对象之间相互引用导致引用计数无法归零的情况。</li></ul><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><ul><li>JavaScript 闭包（Closure）是指在函数内部创建的函数，它可以访问外部函数的变量和作用域，即使外部函数已经执行完毕，闭包仍然可以保持对外部变量的引用。</li></ul><h3 id="特征："><a href="#特征：" class="headerlink" title="特征："></a>特征：</h3><ul><li>内部函数可以访问外部函数的变量和参数</li><li>外部函数的变量不会被销毁</li></ul><h3 id="场景："><a href="#场景：" class="headerlink" title="场景："></a>场景：</h3><ul><li>封装私有变量：通过闭包可以创建私有变量，外部无法直接访问，只能通过闭包提供的接口进行访问和修改。这种方式可以实现数据的封装和保护。</li><li>延迟执行：通过闭包可以创建一个延迟执行的函数，即将一部分逻辑包裹在闭包中，并在需要时执行。这对于实现定时器、事件监听等场景很有用。</li><li>记忆化：闭包可以用于缓存中间计算结果，以避免重复计算。通过在闭包中保存计算结果，可以提高代码的执行效率。<br>  <font color=red>注：</font>闭包的使用需要注意内存管理，因为闭包会持有外部函数的变量引用，如果不及时释放闭包，可能会导致<font color=red>内存泄漏。</font></li></ul><h3 id="释放闭包："><a href="#释放闭包：" class="headerlink" title="释放闭包："></a>释放闭包：</h3><ul><li>如果存在其他对象或函数持有对闭包的引用，可以通过将这些引用置为 null 或者取消相关的事件监听来释放闭包。</li><li>让垃圾回收器自动回收不再使用的闭包所占用的内存。</li></ul><h3 id="避免内存泄漏和资源占用"><a href="#避免内存泄漏和资源占用" class="headerlink" title="避免内存泄漏和资源占用"></a>避免内存泄漏和资源占用</h3><ul><li>及时解除事件监听</li><li>避免循环引用</li><li>尽量避免使用长期存在的闭包</li></ul><h2 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h2><ul><li>默认情况:this指向window（严格模式下为undefined）</li><li>对象绑定:作为对象的方法调用时，this指向该对象</li><li>方法改变: call,apply,bind改变this</li><li>new 绑定： this 指向新创建的实例对象。</li><li>箭头函数： 箭头函数中的 this 绑定是词法上的，指向外层作用域的 this 值，而不是被调用时的上下文对象。</li></ul><h2 id="new实例化"><a href="#new实例化" class="headerlink" title="new实例化"></a>new实例化</h2><ul><li>创建一个空对象</li><li>将对象的原型设置为函数的peototype属性</li><li>将函数的this指向这个对象，执行构造函数的代码，给对象添加属性</li><li>判断函数的返回类型，如果是值类型，则返回这个对象，如果是引用类型，则返回引用类型</li></ul><h2 id="原型-amp-amp-原型链"><a href="#原型-amp-amp-原型链" class="headerlink" title="原型&amp;&amp;原型链"></a>原型&amp;&amp;原型链</h2><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><pre><code>- 在 JavaScript 中，每个对象都有一个原型（prototype）属性，它指向另一个对象，这个对象就是该对象的原型。原型对象可以包含共享的属性和方法，可以被对象实例共享和访问。</code></pre><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><pre><code>- 函数的原型链对象constructor默认指向函数本身，原型对象除了有原型属性外，为了实现继承，还有一个原型链指针__proto__,该指针是指向上一层的原型对象，而上一层的原型对象的结构依然类似。因此可以利用__proto__一直指向Object的原型对象上，而Object原型对象用Object.prototype.__ proto__ = null表示原型链顶端。如此形成了js的原型链继承。同时所有的js对象都有Object的基本防范</code></pre><p>  <font color=#00FFFF>例：</font><br>    <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Person 构造函数的原型对象上定义一个方法</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>!`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个对象实例</span></span><br><span class="line"><span class="keyword">const</span> john = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;John&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用对象实例的方法</span></span><br><span class="line">john.<span class="title function_">sayHello</span>(); <span class="comment">// 输出 &quot;Hello, my name is John!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式访问原型对象上的属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(john.<span class="title function_">toString</span>()); <span class="comment">// 输出 &quot;[object Object]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链继承关系</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(john.<span class="property">__proto__</span> === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// 输出 true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// 输出 true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>); <span class="comment">// 输出 null</span></span><br></pre></td></tr></table></figure></p><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><ul><li>事件循环（Event Loop）是 JavaScript 中处理异步操作的一种机制。它负责协调和执行 JavaScript 代码，使得异步任务能够按照特定的顺序和时机执行。</li><li>JavaScript 是单线程的，意味着一次只能执行一个任务。但是在实际开发中，经常会遇到需要执行异步操作的情况，比如网络请求、定时器、事件监听等。为了处理这些异步操作，JavaScript 引入了事件循环机制。</li></ul><h3 id="事件循环机制的主要组成部分包括以下几个要素"><a href="#事件循环机制的主要组成部分包括以下几个要素" class="headerlink" title="事件循环机制的主要组成部分包括以下几个要素"></a>事件循环机制的主要组成部分包括以下几个要素</h3><pre><code>- 调用栈（Call Stack）：用于存储执行上下文的栈结构，用来跟踪代码的执行位置。- 任务队列（Task Queue）：用于存储异步任务的队列，比如网络请求回调、定时器回调等。- 事件循环（Event Loop）：负责监听调用栈和任务队列，当调用栈为空时，从任务队列中取出任务并推入调用栈执行。</code></pre><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><pre><code>- 代码从上到下依次执行，遇到异步任务时，将其推入任务队列而不会阻塞代码的执行。- 当调用栈为空时，事件循环会检查任务队列。- 如果任务队列中有任务，则选择其中最早进入队列的任务，将其推入调用栈执行。- 执行任务时，可能会产生新的异步任务，将其推入任务队列。- 重复步骤 2-4，直到任务队列为空。</code></pre><ul><li>事件循环中有宏任务和微任务的区分</li></ul><h3 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h3><pre><code>- 整体代码块（Script）：整个脚本代码作为一个宏任务执行。- setTimeout 和 setInterval：定时器任务。- I/O 操作：包括文件读写、网络请求等异步 I/O 操作。- UI 渲染：更新页面布局、样式等操作。- requestAnimationFrame：用于实现动画效果的定时器。- 事件监听器回调：如点击事件、键盘事件等。</code></pre><h3 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h3><pre><code>- Promise 回调：在 Promise 的状态改变时执行的回调函数。- MutationObserver 回调：监测 DOM 变化时执行的回调函数。- process.nextTick（Node.js 环境）：在当前操作结束后立即执行的回调函数。</code></pre><p>  <font color=red>注：事件循环</font>的执行过程中，宏任务的优先级高于微任务。<br>  <font color=red>注：任务队列</font>的执行过程中，微任务的优先级高于宏任务。<br>  <font color=#00FFFF>例：</font><br>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">delay</span>(<span class="params">ms</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, ms));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">syncCode</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">asyncCode</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">      <span class="title function_">resolve</span>();</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">execute</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">syncCode</span>();</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">delay</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">asyncCode</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">delay</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">execute</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">delay</span>(<span class="number">1000</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">delay</span>(<span class="number">1000</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">delay</span>(<span class="number">1000</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">9</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  &lt;!-- 代码执行顺序的解释如下：</span><br><span class="line"></span><br><span class="line">  首先执行 <span class="title function_">syncCode</span>() 函数，输出 <span class="number">1</span>。</span><br><span class="line">  使用 <span class="keyword">await</span> <span class="title function_">delay</span>(<span class="number">1000</span>) 实现一个 <span class="number">1</span> 秒的延迟。</span><br><span class="line">  输出 <span class="number">3</span>。</span><br><span class="line">  执行 <span class="title function_">asyncCode</span>() 函数，其中包含一个 <span class="number">1</span> 秒的延迟，在延迟结束后输出 <span class="number">2</span>。</span><br><span class="line">  输出 <span class="number">4</span>。</span><br><span class="line">  使用 <span class="keyword">await</span> <span class="title function_">delay</span>(<span class="number">1000</span>) 实现一个 <span class="number">1</span> 秒的延迟。</span><br><span class="line">  输出 <span class="number">5</span>。</span><br><span class="line">  使用 <span class="title class_">Promise</span> 的 then 方法进行连续的延时操作，分别输出 <span class="number">6</span>、<span class="number">7</span>、<span class="number">8</span>。</span><br><span class="line">  最后使用 then 方法输出 <span class="number">9</span>。 --&gt;</span><br></pre></td></tr></table></figure></p><h2 id="防抖-amp-amp-节流"><a href="#防抖-amp-amp-节流" class="headerlink" title="防抖&amp;&amp;节流"></a>防抖&amp;&amp;节流</h2><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><ul><li>在事件触发后等待一段时间，如果在这段时间内没有再次触发该事件，才执行对应的操作。如果在等待时间内又触发了该事件，就重新开始计时。<br>  <font color=#00FFFF>例：</font>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">const</span> debouncedFunction = <span class="title function_">debounce</span>(myFunction, <span class="number">300</span>);</span><br><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, debouncedFunction);</span><br></pre></td></tr></table></figure></li></ul><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><ul><li>控制事件的触发频率，保证一定时间内只触发一次该事件。在设定的时间间隔内，不管事件触发了多少次，只有一次事件处理函数执行。<br>  <font color=#00FFFF>例：</font>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">      &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">const</span> throttledFunction = <span class="title function_">throttle</span>(myFunction, <span class="number">300</span>);</span><br><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, throttledFunction);</span><br></pre></td></tr></table></figure></li></ul><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><ul><li>Promise 是 JavaScript 中用于处理异步操作的一种机制。它可以避免回调地狱的问题，并提供了一种更优雅的方式来处理异步代码。</li><li>它可以有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。</li><li>状态只可以改变一次（ pending &#x3D;&#x3D;&gt; fulfilled ||  pending &#x3D;&#x3D;&gt; rejected ）</li><li>可以通过.then()链式调用,每个 .then() 方法都返回一个新的 Promise 对象;</li><li>.then() 方法来注册操作成功时的处理函数，使用 .catch() 方法来注册操作失败时的处理函数。<br>  基本语法 <font color=#00FFFF>例：</font>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 异步操作</span></span><br><span class="line">  <span class="comment">// 如果操作成功，调用 resolve(value)</span></span><br><span class="line">  <span class="comment">// 如果操作失败，调用 reject(error)</span></span><br><span class="line">&#125;);</span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理操作成功的结果</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理操作失败的结果</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><pre><code>#### Promise.resolve  - Promise.resolve(value)：返回一个以给定值解析后的 Promise 对象。如果传入的值本身就是一个 Promise，则直接返回该 Promise。  &lt;font color=#00FFFF&gt;例：&lt;/font&gt;  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 输出 42</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>#### Promise.reject  - Promise.reject(reason)：返回一个带有指定拒绝原因的 Promise 对象。  &lt;font color=#00FFFF&gt;例：&lt;/font&gt;  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Something went wrong&#x27;</span>));</span><br><span class="line">promise.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(error); <span class="comment">// 输出错误信息：Something went wrong</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>#### Promise.all  - Promise.all(iterable)：接收一个可迭代对象（如数组或类数组对象），并返回一个 Promise 对象。  - 该 Promise 对象在所有输入的 Promise 都已成功解析后才会解析，返回一个包含所有 Promise 结果的数组。  - 如果其中任何一个 Promise 被拒绝，则返回的 Promise 会立即被拒绝。  &lt;font color=#00FFFF&gt;例：&lt;/font&gt;  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>),</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">2</span>),</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>)</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>(promises)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">results</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(results); <span class="comment">// 输出 [1, 2, 3]</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>#### Promise.race  - Promise.race(iterable)：接收一个可迭代对象，返回一个 Promise 对象。  - 该 Promise 对象将与第一个解析或拒绝的 Promise 对象具有相同的结果。  &lt;font color=#00FFFF&gt;例：&lt;/font&gt;  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="number">1</span>), <span class="number">100</span>)),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="number">2</span>), <span class="number">200</span>)),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="number">3</span>), <span class="number">300</span>))</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>(promises)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 输出 1（第一个解析的 Promise 结果）</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></code></pre><h3 id="手写实现Promise-all"><a href="#手写实现Promise-all" class="headerlink" title="手写实现Promise.all"></a>手写实现Promise.all</h3>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myPromiseAll</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> results = [];</span><br><span class="line">    <span class="keyword">let</span> resolvedCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      promises[i]</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">          results[i] = result;</span><br><span class="line">          resolvedCount++;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (resolvedCount === promises.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(results);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_">catch</span>(reject);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件委托（事件代理）"><a href="#事件委托（事件代理）" class="headerlink" title="事件委托（事件代理）"></a>事件委托（事件代理）</h2><ul><li>JavaScript 中的事件委托（事件代理）是一种常见的事件处理技术，它通过将事件绑定到一个父元素上，利用事件冒泡的特性，在父元素上统一处理子元素的事件。</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>减少内存消耗：只需要一个事件处理程序，而不是为每个子元素都创建一个处理程序，从而减少了内存消耗。</li><li>动态绑定：对于后续添加的子元素，无需再次绑定事件，因为事件委托是基于事件冒泡的，新添加的元素也会受到委托的处理。</li><li>简化代码：通过将事件处理程序绑定到父元素上，可以避免在多个子元素上编写重复的事件处理代码。<br>  <font color=#00FFFF>例：</font>  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;myList&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> list = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myList&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  list.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (event.<span class="property">target</span>.<span class="property">nodeName</span> === <span class="string">&#x27;LI&#x27;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 在点击的列表项上执行操作</span></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Clicked item:&#x27;</span>, event.<span class="property">target</span>.<span class="property">textContent</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="什么是模块化开发，如何实现模块化开发"><a href="#什么是模块化开发，如何实现模块化开发" class="headerlink" title="什么是模块化开发，如何实现模块化开发"></a>什么是模块化开发，如何实现模块化开发</h2><ul><li>模块化开发是一种软件开发的方法，旨在将代码划分为独立、可维护和可重用的模块。模块化开发有助于提高代码的可读性、可维护性和可测试性，并促进团队合作和代码复用。</li></ul><h3 id="命名空间模式"><a href="#命名空间模式" class="headerlink" title="命名空间模式"></a>命名空间模式</h3><ul><li>使用对象来组织代码，将相关的函数、变量等放在命名空间对象下。这种方式通过避免全局命名冲突来实现模块化。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命名空间模式示例</span></span><br><span class="line"><span class="keyword">var</span> myModule = &#123;</span><br><span class="line">  <span class="comment">// 模块内部的私有数据和函数</span></span><br><span class="line">  <span class="attr">privateData</span>: <span class="string">&#x27;私有数据&#x27;</span>,</span><br><span class="line">  <span class="attr">privateFunction</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 私有函数实现</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 模块内部的公共接口</span></span><br><span class="line">  <span class="attr">publicFunction</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 调用私有函数和访问私有数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="立即执行函数表达式"><a href="#立即执行函数表达式" class="headerlink" title="立即执行函数表达式"></a>立即执行函数表达式</h3><ul><li>使用匿名函数创建一个独立的作用域，并立即执行该函数，从而创建模块化的代码。  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IIFE 模块化示例</span></span><br><span class="line"><span class="keyword">var</span> myModule = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 模块内部的私有数据和函数</span></span><br><span class="line">  <span class="keyword">var</span> privateData = <span class="string">&#x27;私有数据&#x27;</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">privateFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 私有函数实现</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 模块内部的公共接口</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">publicFunction</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 调用私有函数和访问私有数据</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li></ul><h3 id="CommonJS-模块规范"><a href="#CommonJS-模块规范" class="headerlink" title="CommonJS 模块规范"></a>CommonJS 模块规范</h3><ul><li>在服务器端使用广泛的模块化规范，通过 module.exports 导出模块，通过 require 引入模块。  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模块导出</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// 模块的公共接口</span></span><br><span class="line">  <span class="attr">publicFunction</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 实现代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块引入</span></span><br><span class="line"><span class="keyword">var</span> myModule = <span class="built_in">require</span>(<span class="string">&#x27;./myModule&#x27;</span>);</span><br><span class="line">myModule.<span class="title function_">publicFunction</span>();</span><br></pre></td></tr></table></figure></li></ul><h3 id="ES6-模块化"><a href="#ES6-模块化" class="headerlink" title="ES6 模块化"></a>ES6 模块化</h3><ul><li>在现代 JavaScript 中，使用 import 和 export 关键字实现模块化。它是官方标准的模块化方案，广泛支持于现代浏览器和构建工具中。  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模块导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">publicFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 实现代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块引入</span></span><br><span class="line"><span class="keyword">import</span> &#123; publicFunction &#125; <span class="keyword">from</span> <span class="string">&#x27;./myModule&#x27;</span>;</span><br><span class="line"><span class="title function_">publicFunction</span>();</span><br></pre></td></tr></table></figure></li></ul><h2 id="es6模块化和CommonJS的区别"><a href="#es6模块化和CommonJS的区别" class="headerlink" title="es6模块化和CommonJS的区别"></a>es6模块化和CommonJS的区别</h2><ol><li>语法差异<br>- ES6 模块化使用 import 和 export 关键字来导入和导出模块。<br>- CommonJS 使用 require 函数来导入模块，使用 module.exports 来导出模块。</li><li>加载方式差异<br>- ES6 模块化是静态加载的，也就是在代码静态分析阶段就可以确定模块的依赖关系，可以在编译时进行优化和静态分析。<br>- CommonJS 是动态加载的，模块的加载和执行是在运行时进行的，无法在编译时进行优化。</li><li>导入导出特性差异<br>- ES6 模块化支持命名导入和导出，可以选择性地导入和导出模块中的特定成员。<br>- CommonJS 模块化没有内置的命名导入和导出机制，导入的是整个模块对象，可以通过对象属性来访问导出的成员。</li><li>作用域差异<br>- ES6 模块化在导入的模块中，顶层的 import 和 export 声明是静态的，模块内部的变量不会污染全局作用域。<br>- CommonJS 在导入的模块中，整个模块的内容被加载到一个对象中，模块内部的变量和函数都可以被其他模块访问到。</li><li>运行环境差异<br>- ES6 模块化主要用于浏览器环境，也可以通过构建工具（如Webpack、Rollup）在 Node.js 环境中使用。<br>- CommonJS 主要用于 Node.js 环境，也可以通过使用转换工具（如Babel）将其转换为浏览器可用的模块。</li></ol><h2 id="如何操作DOM，常见的操作DOM方式有哪些"><a href="#如何操作DOM，常见的操作DOM方式有哪些" class="headerlink" title="如何操作DOM，常见的操作DOM方式有哪些"></a>如何操作DOM，常见的操作DOM方式有哪些</h2><ol><li>通过 ID 选择元素<br>- document.getElementById(id): 返回指定 ID 的元素。</li><li>通过选择器选择元素<br>- document.querySelector(selector): 返回匹配 CSS 选择器的第一个元素。<br>- document.querySelectorAll(selector): 返回匹配 CSS 选择器的所有元素的 NodeList。</li><li>通过标签名选择元素<br>- document.getElementsByTagName(tagName): 返回指定标签名的元素集合。</li><li>通过类名选择元素<br>- document.getElementsByClassName(className): 返回指定类名的元素集合。</li><li>创建元素<br>- document.createElement(tagName): 创建一个具有指定标签名的元素节点。</li><li>修改元素内容和属性<br>- element.textContent: 设置或获取元素的文本内容。<br>- element.innerHTML: 设置或获取元素的 HTML 内容。<br>- element.setAttribute(name, value): 设置元素的属性。<br>- element.getAttribute(name): 获取元素的属性值。<br>- element.style.property &#x3D; value: 设置元素的 CSS 样式。</li><li>添加，移除和替换元素<br>- element.appendChild(newChild): 在元素的子节点列表末尾添加一个新的子节点。<br>- element.removeChild(child): 从元素的子节点列表中移除指定的子节点。<br>- element.replaceChild(newChild, oldChild): 替换元素的指定子节点。</li><li>添加和移除事件监听器<br>- element.addEventListener(event, listener): 添加事件监听器<br>- element.removeEventListener(event, listener): 移除事件监听器。</li><li>修改元素的样式类<br>- element.classList.add(className): 添加类名。<br>- element.classList.remove(className): 移除类名。<br>- element.classList.toggle(className): 切换类名的状态。</li></ol><h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><ul><li>在 JavaScript 中，变量提升（Hoisting）是一种特性，它指的是在代码执行之前，JavaScript 引擎会将变量和函数的声明提升到当前作用域的顶部。</li></ul><ol><li>声明提升<br>- 在代码执行之前，JavaScript 引擎会扫描当前作用域内的变量声明，并将其提升到作用域顶部。<br>- 可以在变量声明之前使用变量。</li><li>函数提升<br>- 与变量提升类似，JavaScript 引擎还会将函数的声明提升到作用域的顶部<br>- 可以在函数声明之前调用函数。</li></ol><h2 id="for-in和for-of的区别"><a href="#for-in和for-of的区别" class="headerlink" title="for in和for of的区别"></a>for in和for of的区别</h2><ol><li>迭代的对象类型<br>- for…in 循环用于迭代对象的属性，包括对象自身的可枚举属性以及继承的可枚举属性。<br>- for…of 循环用于迭代可迭代对象（如数组、字符串、Set、Map 等）的元素值。</li><li>迭代的顺序<br>- for…in 循环的迭代顺序是不确定的，因为对象的属性没有固定的顺序。<br>- for…of 循环的迭代顺序是按照可迭代对象的迭代器定义的顺序进行迭代。</li><li>迭代变量的类型<br>- for…in 循环中的迭代变量是字符串类型，表示对象的属性名。<br>- for…of 循环中的迭代变量可以是任意类型，表示可迭代对象中的元素值。</li><li>可迭代对象的要求<br>- for…in 循环适用于任何对象，可以用于迭代普通对象的属性。<br>- for…of 循环要求迭代的对象实现了迭代器（Iterator）接口，即具有一个 Symbol.iterator 方法。</li></ol><h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><h3 id="改变原数组"><a href="#改变原数组" class="headerlink" title="改变原数组"></a>改变原数组</h3><pre><code>- push()：向数组末尾添加一个或多个元素，并返回新数组的长度。- pop()：从数组末尾移除最后一个元素，并返回被移除的元素。- unshift()：向数组开头添加一个或多个元素，并返回新数组的长度。- shift()：从数组开头移除第一个元素，并返回被移除的元素。- splice()：从数组中添加、删除或替换元素。- reverse()：颠倒数组中元素的顺序。- sort()：对数组元素进行排序。- fill()：替换值和起始索引位置（可选）。替换值指定要替换的固定值，起始索引位置指定开始替换的位置，默认为 0。</code></pre><h3 id="不改变原数组"><a href="#不改变原数组" class="headerlink" title="不改变原数组"></a>不改变原数组</h3><pre><code>- concat()：将两个或多个数组合并为一个新数组。- join()：将数组中的所有元素连接成一个字符串，并返回该字符串。- slice()：返回数组的指定部分（浅拷贝）。- indexOf()：返回指定元素在数组中的第一个匹配位置的索引。- lastIndexOf()：返回指定元素在数组中最后一个匹配位置的索引。- forEach()：对数组中的每个元素执行指定的函数。- map()：对数组中的每个元素执行指定的函数，并返回一个新数组。- filter()：根据指定的条件过滤数组中的元素，并返回一个新数组。- reduce()：对数组中的元素执行累加器函数，返回一个累计值。- every()：检查数组中的每个元素是否满足指定条件。- some()：检查数组中是否至少有一个元素满足指定条件。- find()：返回数组中满足指定条件的第一个元素。- findIndex()：返回数组中满足指定条件的第一个元素的索引。</code></pre><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><ol><li>使用 Set  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> uniqueArr = [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(uniqueArr); <span class="comment">// 输出 [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li><li>使用 filter() 和 indexOf()  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> uniqueArr = arr.<span class="title function_">filter</span>(<span class="function">(<span class="params">value, index, array</span>) =&gt;</span> array.<span class="title function_">indexOf</span>(value) === index);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(uniqueArr); <span class="comment">// 输出 [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li><li>使用 reduce() 和 includes()：  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> uniqueArr = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">result, value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!result.<span class="title function_">includes</span>(value)) &#123;</span><br><span class="line">    result.<span class="title function_">push</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;, []);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(uniqueArr); <span class="comment">// 输出 [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h3><pre><code>1. 递归<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">function</span> <span class="title function_">flattenArray</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> flattened = [];</span><br><span class="line">  arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(item)) &#123;</span><br><span class="line">      flattened = flattened.<span class="title function_">concat</span>(<span class="title function_">flattenArray</span>(item));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      flattened.<span class="title function_">push</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> flattened;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nestedArray = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>], <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> flattenedArray = <span class="title function_">flattenArray</span>(nestedArray);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(flattenedArray); <span class="comment">// 输出 [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>2. Array.prototype.flat()<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nestedArray = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>], <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> flattenedArray = nestedArray.<span class="title function_">flat</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(flattenedArray); <span class="comment">// 输出 [1, 2, [3, 4], 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nestedArray = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>], <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> flattenedArray = nestedArray.<span class="title function_">flat</span>(<span class="number">2</span>); <span class="comment">// 指定扁平化层数为 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(flattenedArray); <span class="comment">// 输出 [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>3. 扩展运算符+递归<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flattenArray</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">result, item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(item)) &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(...<span class="title function_">flattenArray</span>(item));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nestedArray = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>], <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> flattenedArray = <span class="title function_">flattenArray</span>(nestedArray);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(flattenedArray); <span class="comment">// 输出 [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端css面试题</title>
      <link href="/2023/05/22/html,css%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2023/05/22/html,css%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>近期准备换个坑位，所以整理了一些面试题，希望有用！<br>本篇主要以html和css内容为主，如需其他，请阅读其他文章。</p><h2 id="HTML5-新特性、语义化"><a href="#HTML5-新特性、语义化" class="headerlink" title="HTML5 新特性、语义化"></a>HTML5 新特性、语义化</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><pre><code>HTML5的语义化指的是合理的使用语义化的标签来创建页面结构。【正确的标签做正确的事】</code></pre><h3 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h3><pre><code>header(头部)  - 通常包含页面的标题、导航菜单、品牌标识等与页面头部相关的内容nav(导航栏)  - 用于表示页面中的导航菜单或导航链接集合。main(内容区域)  - 一般一个页面只应有一个main标签article(表示独立、完整、可以独立分配或复用的内容块的元素)  - article标签应该包含独立的、自包含的内容，而不是被其他元素依赖或嵌套使用section(独立内容区块的元素)  - 用于将相关的内容组织在一起，通常具有一个标题或主题。aside(侧边栏)  - 通常包含与页面主要内容相关但又可以作为补充的内容  - 不仅限于侧边栏的用法，它也可以用于其他附加信息的展示，例如广告、引用、附属内容等footer(底部内容)  - 通常包含与页面相关的版权信息、联系信息、导航链接等。</code></pre><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><pre><code>- 在没CSS样式的情况下，页面整体也会呈现很好的结构效果- 代码结构清晰，易于阅读，- 利于开发和维护 方便其他设备解析（如屏幕阅读器）根据语义渲染网页。- 有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重</code></pre><h2 id="css选择器优先级"><a href="#css选择器优先级" class="headerlink" title="css选择器优先级"></a>css选择器优先级</h2><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><pre><code>- 元素选择器：通过元素名称选取元素，如 p 选择所有 &lt;p&gt; 元素。- 类选择器：通过类名选取元素，以.开头，如 .my-class 选择所有具有 my-class 类名的元素。- ID选择器：通过元素的唯一ID选取元素，以#开头，如 #my-id 选择具有 my-id ID的元素。- 属性选择器：通过元素的属性值选取元素，如 [type=&quot;text&quot;] 选择所有 type 属性值为 text 的元素。- 后代选择器：通过元素的后代关系选取元素，使用空格分隔，如 div p 选择所有 &lt;p&gt; 元素，它们是 &lt;div&gt; 元素的后代。- 直接子元素选择器：通过元素的直接子元素关系选取元素，使用 &gt; 分隔，如 div &gt; p 选择所有 &lt;p&gt; 元素，它们是 &lt;div&gt; 元素的直接子元素。- 兄弟选择器：通过元素的兄弟关系选取元素，使用 + 分隔，如 h2 + p 选择紧接在 &lt;h2&gt; 元素后的 &lt;p&gt; 元素。- 伪类选择器：通过元素的状态或特定条件选取元素，以:开头，如 :hover 选择鼠标悬停在元素上的状态。- 伪元素选择器：通过元素的特定部分选取元素，以::开头，如 ::before 选择元素的前置内容。</code></pre><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><pre><code>1. ！important2. 内联样式3. ID选择器4. 类选择器，属性选择器，伪类选择器5. 元素选择器，伪元素选择器6. 通配符，子类，相邻选择器</code></pre><h2 id="position-属性的值有哪些及其区别"><a href="#position-属性的值有哪些及其区别" class="headerlink" title="position 属性的值有哪些及其区别"></a>position 属性的值有哪些及其区别</h2><h3 id="static-默认值"><a href="#static-默认值" class="headerlink" title="static(默认值):"></a>static(默认值):</h3><pre><code>- 元素按照正常文档流进行定位，不受 top、right、bottom、left 等属性的影响。</code></pre><h3 id="relative-相对定位"><a href="#relative-相对定位" class="headerlink" title="relative(相对定位):"></a>relative(相对定位):</h3><pre><code>- 元素相对于其正常位置进行定位，通过设置 top、right、bottom、left 属性来调整元素的位置。相对定位不会影响其他元素的布局。</code></pre><h3 id="absolute-绝对定位"><a href="#absolute-绝对定位" class="headerlink" title="absolute(绝对定位):"></a>absolute(绝对定位):</h3><pre><code>- 元素相对于其最近的已定位（非 static）的父元素进行定位，如果没有已定位的父元素，则相对于文档根元素进行定位。通过设置 top、right、 bottom、  left 属性来指定元素的精确位置。绝对定位会使元素脱离正常文档流，并且不会为其保留空间。</code></pre><h3 id="fixed-固定定位"><a href="#fixed-固定定位" class="headerlink" title="fixed(固定定位):"></a>fixed(固定定位):</h3><pre><code>- 元素相对于视口进行定位，即无论页面滚动与否，元素都会保持在固定位置。通过设置 top、right、bottom、left 属性来指定元素的精确位置。</code></pre><h3 id="sticky-粘性定位"><a href="#sticky-粘性定位" class="headerlink" title="sticky(粘性定位):"></a>sticky(粘性定位):</h3><pre><code>- 元素根据正常文档流进行定位，但在滚动到特定阈值时，会变为固定定位。通过设置 top、right、bottom、left 属性和 top、bottom 等阈值来调整元素的位置和触发条件。</code></pre><h2 id="box-sizing属性-盒模型"><a href="#box-sizing属性-盒模型" class="headerlink" title="box-sizing属性(盒模型)"></a>box-sizing属性(盒模型)</h2><h3 id="content-box-标准盒模型"><a href="#content-box-标准盒模型" class="headerlink" title="content-box(标准盒模型)"></a>content-box(标准盒模型)</h3><pre><code>- 宽度和高度分别应用到元素的内容框，在宽度和高度之外绘制元素的内边距和边框。- width 指 content 部分的宽度。</code></pre><h3 id="border-box-IE-盒子模型-怪异盒模型"><a href="#border-box-IE-盒子模型-怪异盒模型" class="headerlink" title="border-box(IE 盒子模型 | 怪异盒模型)"></a>border-box(IE 盒子模型 | 怪异盒模型)</h3><pre><code>- 为元素设定的宽度和高度决定了元素的边框盒。- width 表示 content+padding+border 这三个部分的宽度。</code></pre><h3 id="inherit"><a href="#inherit" class="headerlink" title="inherit"></a>inherit</h3><pre><code>- 继承父元素的 box-sizing 值。</code></pre><h2 id="BFC（块级格式上下文）"><a href="#BFC（块级格式上下文）" class="headerlink" title="BFC（块级格式上下文）"></a>BFC（块级格式上下文）</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><pre><code>- 块级格式化上下文（Block Formatting Context，BFC）是CSS中的一个概念，用于描述元素在布局时的一种独立的渲染区域。每个BFC都是一个独立的容器，内部元素的布局不会影响到外部元素。</code></pre><h3 id="主要特征"><a href="#主要特征" class="headerlink" title="主要特征"></a>主要特征</h3><pre><code>- 内部元素垂直方向的边距会发生重叠：当多个块级元素嵌套在同一个BFC中时，它们的上下边距可能会发生重叠。- BFC可以包含浮动元素：当一个元素触发了BFC，它可以包含浮动元素，并阻止浮动元素溢出到其他区域。- BFC可以阻止浮动元素造成的父元素塌陷：当一个元素的子元素都浮动时，如果父元素触发了BFC，它会根据子元素的高度进行布局，不会因为浮动元素而塌陷。- BFC在页面布局中的应用：通过触发元素的BFC特性，可以实现一些布局效果，如清除浮动、创建自适应的多栏布局等。</code></pre><h3 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式"></a>触发方式</h3><pre><code>- 根元素（&lt;html&gt;）是一个BFC。- 设置元素的 float 属性为除 none 以外的值。- 设置元素的 position 属性为 absolute 或 fixed。- 设置元素的 display 属性为 inline-block、table-cell、table-caption 或 flex。</code></pre><h2 id="元素水平垂直居中"><a href="#元素水平垂直居中" class="headerlink" title="元素水平垂直居中"></a>元素水平垂直居中</h2><h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><pre><code><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="定位实现"><a href="#定位实现" class="headerlink" title="定位实现"></a>定位实现</h3><ul><li>方式一:<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>方式二:   <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="flex布局-1"><a href="#flex布局-1" class="headerlink" title="flex布局"></a>flex布局</h3><pre><code><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h2 id="隐藏元素的方式"><a href="#隐藏元素的方式" class="headerlink" title="隐藏元素的方式"></a>隐藏元素的方式</h2><ul><li>display: none;<ul><li>元素完全被隐藏掉，文档流中不占据空间，改变布局。</li><li>不可触发事件。</li></ul></li><li>visibility: hidden;<ul><li>元素隐藏掉，但仍占据空间，不改变布局。</li><li>不可触发事件</li></ul></li><li>opacity: 0;<ul><li>元素变为透明，视觉上不可见，仍占据空间。</li><li>可触发事件。</li></ul></li></ul><h2 id="css实现三角形"><a href="#css实现三角形" class="headerlink" title="css实现三角形"></a>css实现三角形</h2><ul><li>思路： 宽高设为0，边框给一定粗度，然后将三边设置为透明</li><li>使用边框：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">100px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>使用伪元素：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.element</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">100px</span> solid blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="伪类和伪元素的区别"><a href="#伪类和伪元素的区别" class="headerlink" title="伪类和伪元素的区别"></a>伪类和伪元素的区别</h2><ul><li>伪类选择的是满足某个条件的元素，而伪元素选择的是元素的某个部分。</li><li>伪类以单冒号（:）开头，伪元素以双冒号（::）开头。</li><li>伪类用于选择元素的状态或行为，而伪元素用于插入或生成元素的内容。</li></ul><h2 id="实现响应式设计"><a href="#实现响应式设计" class="headerlink" title="实现响应式设计"></a>实现响应式设计</h2><h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><ul><li>媒体查询是 CSS 中的一种功能，它允许根据不同的媒体特性（如屏幕宽度、设备类型等）应用不同的样式。通过在 CSS 中定义不同的媒体查询规则，可以根据设备的特征为不同的屏幕尺寸提供不同的布局和样式。</li></ul><h3 id="弹性网格布局"><a href="#弹性网格布局" class="headerlink" title="弹性网格布局"></a>弹性网格布局</h3><ul><li>弹性网格布局使用相对单位（如百分比）来定义网格的列宽和行高，使得布局可以根据屏幕尺寸的变化自动调整。通过使用弹性网格布局，网页的各个元素可以根据屏幕大小灵活地改变宽度和位置。</li></ul><h3 id="流式布局"><a href="#流式布局" class="headerlink" title="流式布局"></a>流式布局</h3><ul><li>流式布局使用相对单位和百分比来定义元素的尺寸，使得页面可以根据屏幕尺寸进行伸缩。相对于固定的像素单位，流式布局可以更好地适应不同设备的屏幕尺寸，提供更好的响应性。</li></ul><h3 id="图片响应式设计"><a href="#图片响应式设计" class="headerlink" title="图片响应式设计"></a>图片响应式设计</h3><ul><li>图片响应式设计通过使用不同的图片源（如不同大小或分辨率的图片）来适应不同的屏幕尺寸。可以使用 CSS 的 max-width 属性和 <img> 标签的 srcset 属性来实现图片的响应式展示，以确保在不同设备上加载适合的图片。</li></ul><h3 id="设备像素比"><a href="#设备像素比" class="headerlink" title="设备像素比"></a>设备像素比</h3><ul><li>设备像素比是设备物理像素与 CSS 像素之间的比率。通过使用媒体查询和 CSS 的 min-device-pixel-ratio 或 max-device-pixel-ratio 属性，可以针对不同的设备像素比提供不同的样式和布局。<h4 id="min-device-pixel-ratio-amp-amp-max-device-pixel-ratio"><a href="#min-device-pixel-ratio-amp-amp-max-device-pixel-ratio" class="headerlink" title="min-device-pixel-ratio &amp;&amp; max-device-pixel-ratio"></a>min-device-pixel-ratio &amp;&amp; max-device-pixel-ratio</h4><ul><li>是一个用于媒体查询的 CSS 属性，用于检测设备的像素密度。它用于确定设备物理像素和 CSS 像素之间的比率，并根据设备的像素密度应用不同的样式或布局<br><font color=#00FFFF>例：</font>下面的媒体查询将应用于 min-device-pixel-ratio 属性，仅在设备像素密度比率大于或等于 2 的情况下生效<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>: <span class="number">2</span>),</span><br><span class="line">      (<span class="attribute">min--moz-device-pixel-ratio</span>: <span class="number">2</span>),</span><br><span class="line">      (<span class="attribute">min-device-pixel-ratio</span>: <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="comment">/* 根据高像素密度设备的需要应用样式或布局 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font color=red>注：</font> min-device-pixel-ratio 属性的值是一个 <font color=red>浮点数</font>，可以根据具体需求进行调整和匹配。同时，由于不同浏览器和设备对于 min-device-pixel-ratio 的支持可能存在差异，建议在使用时进行适当的兼容性处理和测试。</li></ul></li></ul><h2 id="优雅降级和渐进增强"><a href="#优雅降级和渐进增强" class="headerlink" title="优雅降级和渐进增强"></a>优雅降级和渐进增强</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul><li>优雅降级和渐进增强是两种前端开发的策略，用于确保网站或应用在不同浏览器或设备上具备基本的可用性和用户体验。</li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><pre><code>- 优雅降级是指首先针对具有较高性能和功能的现代浏览器开发网站或应用，然后逐步提供对较旧或不支持某些功能的浏览器的支持。- 渐进增强是指从基本的、核心功能开始，然后根据浏览器的能力逐步增强网站或应用的功能和体验。</code></pre><h2 id="动画（animation）"><a href="#动画（animation）" class="headerlink" title="动画（animation）"></a>动画（animation）</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li>animation-name：定义动画的名称，对应关键帧规则中的动画名称。</li><li>animation-duration：指定动画的持续时间，单位可以是秒（s）或毫秒（ms）。</li><li>animation-timing-function：设置动画的时间函数，控制动画的速度变化。</li><li>animation-delay：指定动画开始之前的延迟时间，单位可以是秒（s）或毫秒（ms）。</li><li>animation-iteration-count：定义动画的播放次数，可以是具体的次数或 infinite（无限循环）。</li><li>animation-direction：指定动画的播放方向，可以是 normal（正向播放）、reverse（反向播放）或 alternate（来回播放）。</li><li>animation-fill-mode：设置动画在播放之前和之后的样式状态，可以是 none、forwards、backwards 或 both。</li><li>animation-play-state：控制动画的播放状态，可以是 paused（暂停）或 running（播放）。<br>  <font color=red>注：</font> 除了上述属性外，还有一些与动画相关的属性，如 <font color=red>transform、opacity、transition</font> 等，它们可以与动画属性结合使用，实现更丰富的动画效果。<br>  <font color=#00FFFF>例：</font>  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> fade-in &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">  <span class="attribute">animation-name</span>: fade-in;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">animation-delay</span>: <span class="number">1s</span>;</span><br><span class="line">  <span class="attribute">animation-timing-function</span>: ease-in-out;</span><br><span class="line">  <span class="attribute">animation-iteration-count</span>: infinite;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- 上述示例定义了一个名为 &quot;fade-in&quot; 的动画，通过逐渐改变元素的透明度，实现了一个淡入效果。然后将动画应用于具有 &quot;<span class="selector-class">.element</span>&quot; 类的元素，并设置动画的持续时间为 <span class="number">2</span> 秒，延迟时间为 <span class="number">1</span> 秒，时间函数为 ease-in-out，并无限循环播放。通过组合和调整这些动画属性，可以创建各种各样的 CSS 动画效果，如淡入淡出、平移、旋转、缩放等。根据具体的需求和创意，可以灵活运用这些属性来设计和实现自定义的动画效果。 --&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="如何实现溢出省略号"><a href="#如何实现溢出省略号" class="headerlink" title="如何实现溢出省略号"></a>如何实现溢出省略号</h2><h3 id="单行省略号"><a href="#单行省略号" class="headerlink" title="单行省略号"></a>单行省略号</h3>  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.ellipsis</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>; <span class="comment">/* 设置容器的宽度，根据需要进行调整 */</span></span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多行省略号"><a href="#多行省略号" class="headerlink" title="多行省略号"></a>多行省略号</h3><pre><code><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.ellipsis</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">  -webkit-box-orient: vertical;</span><br><span class="line">  -webkit-line-clamp: <span class="number">3</span>; <span class="comment">/* 设置显示的最大行数，根据需要进行调整 */</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>only office 相关参数设置说明</title>
      <link href="/2023/05/11/only-office-01/"/>
      <url>/2023/05/11/only-office-01/</url>
      
        <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">initDoc</span>(<span class="params">key, url, fileType, title, model, callbackUrl</span>) &#123;</span><br><span class="line">                <span class="keyword">let</span> config = &#123;</span><br><span class="line">                    <span class="string">&quot;document&quot;</span>: &#123;</span><br><span class="line">                        <span class="string">&quot;documentType&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;width&quot;</span>: <span class="string">&quot;100%&quot;</span>, <span class="comment">//打开窗口宽度</span></span><br><span class="line">                        <span class="string">&quot;height&quot;</span>: <span class="string">&quot;100%&quot;</span>, <span class="comment">//打开窗口高度</span></span><br><span class="line">                        <span class="string">&quot;fileType&quot;</span>: fileType, <span class="comment">//文档类型</span></span><br><span class="line">                        <span class="string">&quot;key&quot;</span>: key, <span class="comment">//定义用于服务识别文档的唯一文档标识符。每次编辑和保存文档时，都必须重新生成密钥。长度限制为128个符号。</span></span><br><span class="line">                        <span class="string">&quot;title&quot;</span>: title, <span class="comment">//为查看或编辑的文档定义所需的文件名，该文件名也将在下载文档时用作文件名。长度限制为128个符号。</span></span><br><span class="line">                        <span class="string">&quot;url&quot;</span>: url, <span class="comment">//定义存储原始查看或编辑的文档的绝对URL</span></span><br><span class="line">                        <span class="string">&quot;info&quot;</span>: &#123;</span><br><span class="line">                            <span class="string">&quot;owner&quot;</span>: <span class="string">&quot;王重阳&quot;</span>, <span class="comment">//文件创建者名称</span></span><br><span class="line">                            <span class="string">&quot;sharingSettings&quot;</span>: [ <span class="comment">//文件对应用户的操作权限配置</span></span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="string">&quot;permissions&quot;</span>: <span class="string">&quot;Full Access&quot;</span>, <span class="comment">// 完全操作权限-Full Access,只读权限-Read Only 拒绝访问-Deny Access</span></span><br><span class="line">                                    <span class="string">&quot;user&quot;</span>: <span class="string">&quot;林朝英&quot;</span> <span class="comment">//有次权限的用户</span></span><br><span class="line">                                &#125;,</span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="string">&quot;permissions&quot;</span>: <span class="string">&quot;Read Only&quot;</span>,</span><br><span class="line">                                    <span class="string">&quot;user&quot;</span>: <span class="string">&quot;周伯通&quot;</span></span><br><span class="line">                                &#125;,</span><br><span class="line">                            ],</span><br><span class="line">                            <span class="string">&quot;uploaded&quot;</span>: <span class="string">&quot;2010-07-07 3:46 PM&quot;</span> <span class="comment">//文件创建时间</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="comment">//文档权限参数</span></span><br><span class="line">                        <span class="string">&quot;permissions&quot;</span>: &#123;</span><br><span class="line">                            <span class="string">&quot;edit&quot;</span>: <span class="literal">true</span>, <span class="comment">//（文件是否可以编辑，false时文件不可编辑）</span></span><br><span class="line">                            <span class="string">&quot;fillForms&quot;</span>: <span class="literal">true</span>, <span class="comment">//定义是否能在文档中填充表单</span></span><br><span class="line">                            <span class="string">&quot;print&quot;</span>: <span class="literal">true</span>, <span class="comment">//定义文档是否能打印</span></span><br><span class="line">                            <span class="string">&quot;review&quot;</span>: <span class="literal">false</span>, <span class="comment">//第一是否显示审阅文档菜单</span></span><br><span class="line">                            <span class="string">&quot;comment&quot;</span>: <span class="literal">true</span>, <span class="comment">//定义是否可以注释文档。如果注释权限设置为“ true”，则文档侧栏将包含“注释”菜单选项；只有将mode参数设置为edit时才生效，默认值与edit参数的值一致。</span></span><br><span class="line">                            <span class="string">&quot;copy&quot;</span>: <span class="literal">true</span>, <span class="comment">//是否允许您将内容复制到剪贴板。默认值为true。</span></span><br><span class="line">                            <span class="string">&quot;download&quot;</span>: <span class="literal">true</span>, <span class="comment">//定义是否可以下载文档或仅在线查看或编辑文档。如果下载权限设置为“false”下载为菜单选项将没有。默认值为true。</span></span><br><span class="line">                            <span class="string">&quot;modifyContentControl&quot;</span>: <span class="literal">true</span>, <span class="comment">//定义是否可以更改内容控件设置。仅当mode参数设置为edit时，内容控件修改才可用于文档编辑器。默认值为true。</span></span><br><span class="line">                            <span class="string">&quot;modifyFilter&quot;</span>: <span class="literal">true</span>, <span class="comment">//定义过滤器是否可以全局应用（true）影响所有其他用户，或局部应用（false），即仅适用于当前用户。如果将mode参数设置为edit，则过滤器修改仅对电子表格编辑器可用。默认值为true。</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="comment">// type: &quot;embedded&quot;,</span></span><br><span class="line">                    <span class="comment">//打开文档类型</span></span><br><span class="line">                    <span class="comment">// text对应各种文档类型(.doc, .docm, .docx, .dot, .dotm, .dotx, .epub, .fodt, .htm, .html, .mht, .odt, .ott, .pdf, .rtf, .txt, .djvu, .xps)</span></span><br><span class="line">                    <span class="comment">//spreadsheet对应表格类型(.csv, .fods, .ods, .ots, .xls, .xlsm, .xlsx, .xlt, .xltm, .xltx)</span></span><br><span class="line">                    <span class="comment">//presentation对应PPT类型(.fodp, .odp, .otp, .pot, .potm, .potx, .pps, .ppsm, .ppsx, .ppt, .pptm, .pptx)</span></span><br><span class="line">                    <span class="string">&quot;editorConfig&quot;</span>: &#123; <span class="comment">//编辑配置</span></span><br><span class="line">                        <span class="string">&quot;createUrl&quot;</span>: <span class="string">&quot;http://docServer:port/url-to-create-document/&quot;</span>, <span class="comment">//指定创建文件的页面,添加该配置后文档服务器插件才会显示新建文件按钮</span></span><br><span class="line">                        <span class="string">&quot;mode&quot;</span>: model, <span class="comment">//文档操作模式 view 视图模式不可编辑  edit 编辑模式可编辑文档</span></span><br><span class="line">                        <span class="string">&quot;callbackUrl&quot;</span>: callbackUrl, <span class="comment">//保存文件时的回调地址</span></span><br><span class="line">                        <span class="string">&quot;lang&quot;</span>: <span class="string">&quot;zh-CN&quot;</span>, <span class="comment">//语言环境</span></span><br><span class="line">                        <span class="string">&quot;customization&quot;</span>: &#123; <span class="comment">//定制部分允许自定义编辑器界面，使其看起来像您的其他产品，并更改是否存在其他按钮，链接，更改徽标和编辑者所有者详细信息。</span></span><br><span class="line">                            <span class="string">&quot;help&quot;</span>: <span class="literal">false</span>, <span class="comment">//定义是显示还是隐藏“帮助”菜单按钮。默认值为true。</span></span><br><span class="line">                            <span class="string">&quot;hideRightMenu&quot;</span>: <span class="literal">false</span>, <span class="comment">//定义在第一次加载时是显示还是隐藏右侧菜单。默认值为false。</span></span><br><span class="line">                            <span class="string">&quot;autosave&quot;</span>: <span class="literal">false</span>, <span class="comment">//定义是启用还是禁用“自动保存”菜单选项。请注意，如果您在菜单中更改此选项，它将被保存到浏览器的localStorage中。默认值为true。</span></span><br><span class="line">                            <span class="string">&quot;forcesave&quot;</span>: <span class="literal">true</span>, <span class="comment">//定义保存按钮是否显示默认false</span></span><br><span class="line">                            <span class="string">&quot;chat&quot;</span>: <span class="literal">false</span>, <span class="comment">//定义“聊天”菜单按钮是显示还是隐藏；请注意，如果您隐藏“聊天”按钮，则相应的聊天功能也将被禁用。默认值为true。</span></span><br><span class="line">                            <span class="string">&quot;commentAuthorOnly&quot;</span>: <span class="literal">false</span>, <span class="comment">//定义用户是否只能编辑和删除他的评论。默认值为false。</span></span><br><span class="line">                            <span class="string">&quot;comments&quot;</span>: <span class="literal">false</span>, <span class="comment">//定义是显示还是隐藏“注释”菜单按钮；请注意，如果您隐藏“评论”按钮，则相应的评论功能将仅可用于查看，评论的添加和编辑将不可用。默认值为true。</span></span><br><span class="line">                            <span class="string">&quot;compactHeader&quot;</span>: <span class="literal">false</span>, <span class="comment">//定义是否将菜单栏放在在徽标旁边使界面更加紧凑默认false。</span></span><br><span class="line">                            <span class="string">&quot;compactToolbar&quot;</span>: <span class="literal">false</span>, <span class="comment">//定义显示的顶部工具栏类型是完整（false）还是紧凑true。默认值为false 多余菜单将在右侧折叠点击显示。</span></span><br><span class="line">                            <span class="string">&quot;compatibleFeatures&quot;</span>: <span class="literal">false</span>, <span class="comment">//定义仅与OOXML格式兼容的功能的使用。例如，不要在整个文档上使用注释。默认值为false。</span></span><br><span class="line">                            <span class="string">&quot;macros&quot;</span>: <span class="literal">false</span>, <span class="comment">//定义是否将运行文档宏以及可用的宏设置。默认值为true。</span></span><br><span class="line">                            <span class="string">&quot;macrosMode&quot;</span>: <span class="string">&quot;warn&quot;</span>, <span class="comment">//定义是否将运行文档宏。可以采用以下值： disable -根本不运行；enable -自动运行所有宏；warn -警告宏并请求允许运行。默认值为original。</span></span><br><span class="line">                            <span class="string">&quot;plugins&quot;</span>: <span class="literal">false</span>, <span class="comment">//定义是否将启动插件并可用。默认值为true。</span></span><br><span class="line">                            <span class="string">&quot;showReviewChanges&quot;</span>: <span class="literal">false</span>, <span class="comment">//定义在加载编辑器时是否自动显示或隐藏审阅更改面板。默认值为false。</span></span><br><span class="line">                            <span class="string">&quot;spellcheck&quot;</span>: <span class="literal">false</span>, <span class="comment">//定义在加载编辑器时是否自动打开或关闭拼写检查器。拼写检查器仅适用于文档编辑器和演示文稿编辑器。默认值为true。</span></span><br><span class="line">                            <span class="string">&quot;toolbarNoTabs&quot;</span>: <span class="literal">false</span>, <span class="comment">//定义是突出显示顶部工具栏选项卡样式。默认值为false。</span></span><br><span class="line">                            <span class="string">&quot;unit&quot;</span>: <span class="string">&quot;cm&quot;</span>, <span class="comment">//定义在标尺和对话框中使用的度量单位。可以采用以下值：cm -厘米，pt-点，inch -英寸。默认值为厘米（cm）。</span></span><br><span class="line">                            <span class="string">&quot;zoom&quot;</span>: <span class="number">100</span>, <span class="comment">//定义以百分比为单位的文档显示缩放值。可以取大于0的值。对于文本文档和演示文稿，可以将此参数设置为-1（使文档适合页面选项）或-2（使文档页面宽度适合编辑器页面）。默认值为100。</span></span><br><span class="line">                            <span class="string">&quot;customer&quot;</span>: &#123; <span class="comment">//关于 文档编辑器的显示信息</span></span><br><span class="line">                                <span class="string">&quot;address&quot;</span>: <span class="string">&quot;My City, 123a-45&quot;</span>, <span class="comment">//有权访问编辑或编辑作者的公司或个人的邮政地址，</span></span><br><span class="line">                                <span class="string">&quot;info&quot;</span>: <span class="string">&quot;Some additional information&quot;</span>, <span class="comment">//有关您希望其他人认识的公司或个人的一些其他信息，</span></span><br><span class="line">                                <span class="string">&quot;logo&quot;</span>: <span class="string">&quot;https://example.com/logo-big.png&quot;</span>, <span class="comment">//图片徽标的路径（此文件没有特别建议，但是如果使用透明背景的.png格式会更好）。图片必须具有以下尺寸：432x70，</span></span><br><span class="line">                                <span class="string">&quot;mail&quot;</span>: <span class="string">&quot;john@example.com&quot;</span>, <span class="comment">//有权访问编辑者或编辑者的公司或个人的电子邮件地址</span></span><br><span class="line">                                <span class="string">&quot;name&quot;</span>: <span class="string">&quot;欧阳锋&quot;</span>, <span class="comment">//该公司或个人的谁可以访问编辑或编辑作者，名称</span></span><br><span class="line">                                <span class="string">&quot;www&quot;</span>: <span class="string">&quot;example.com&quot;</span> <span class="comment">//以上公司或个人的家庭网站地址，</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            <span class="string">&quot;feedback&quot;</span>: &#123; <span class="comment">//反馈配置信息</span></span><br><span class="line">                                <span class="string">&quot;url&quot;</span>: <span class="string">&quot;https://example.com&quot;</span>, <span class="comment">//单击“反馈和支持”菜单按钮时将打开的网站地址的绝对URL ，</span></span><br><span class="line">                                <span class="string">&quot;visible&quot;</span>: <span class="literal">false</span> <span class="comment">//显示或隐藏“反馈和支持”菜单按钮，</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            <span class="string">&quot;goback&quot;</span>: &#123; <span class="comment">//定义“打开文件位置”菜单按钮和右上角按钮的设置。该对象具有以下参数：</span></span><br><span class="line">                                <span class="string">&quot;blank&quot;</span>: <span class="literal">true</span>, <span class="comment">//在新的浏览器选项卡/窗口（如果值设置为true）或当前选项卡（如果值设置为false）中打开网站。默认值为true，</span></span><br><span class="line">                                <span class="string">&quot;requestClose&quot;</span>: <span class="literal">false</span>, <span class="comment">//定义如果单击“打开文件位置”按钮，则调用events.onRequestClose事件，而不是打开浏览器选项卡或窗口。默认值为false，</span></span><br><span class="line">                                <span class="string">&quot;text&quot;</span>: <span class="string">&quot;Open file location&quot;</span>, <span class="comment">//将在“打开文件位置”菜单按钮和右上角按钮（即，而不是“转到文档”）上显示的文本，</span></span><br><span class="line">                                <span class="string">&quot;url&quot;</span>: <span class="string">&quot;https://example.com&quot;</span> <span class="comment">//单击“打开文件位置”菜单按钮时将打开的网站地址的绝对URL ，</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            <span class="string">&quot;logo&quot;</span>: &#123;</span><br><span class="line">                                <span class="string">&quot;image&quot;</span>: <span class="string">&quot;https://example.com/logo.png&quot;</span>, <span class="comment">//图像文件的路径，用于在普通工作模式下显示（即，在所有编辑器的查看和编辑模式下）。图片必须具有以下尺寸：172x40，</span></span><br><span class="line">                                <span class="string">&quot;imageEmbedded&quot;</span>: <span class="string">&quot;https://example.com/logo_em.png&quot;</span>, <span class="comment">//用于以嵌入式模式显示的图像文件的路径（请参阅config部分以了解如何定义嵌入式文档类型）。图片必须具有以下尺寸：248x40，</span></span><br><span class="line">                                <span class="string">&quot;url&quot;</span>: <span class="string">&quot;https://www.baidu.com&quot;</span> <span class="comment">//某人单击徽标图像时将使用的绝对URL（可用于转到您的网站等）。保留为空字符串或null以使徽标不可单击，</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="string">&quot;user&quot;</span>: &#123; <span class="comment">//用户信息</span></span><br><span class="line">                            <span class="string">&quot;id&quot;</span>: <span class="string">&quot;admin&quot;</span>, <span class="comment">//用户ID</span></span><br><span class="line">                            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;操作员&quot;</span> <span class="comment">//用户全名称</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="string">&quot;embedded&quot;</span>: &#123; <span class="comment">//Embedded部分仅适用于嵌入式文档类型（请参阅config部分以了解如何定义嵌入式文档类型）。它允许更改设置，这些设置定义嵌入式模式下按钮的行为。</span></span><br><span class="line">                            <span class="string">&quot;embedUrl&quot;</span>: <span class="string">&quot;https://example.com/embedded?doc=exampledocument1.docx&quot;</span>, <span class="comment">//定义文档的绝对URL，以作为嵌入到网页中的文档的源文件</span></span><br><span class="line">                            <span class="string">&quot;fullscreenUrl&quot;</span>: <span class="string">&quot;https://example.com/embedded?doc=exampledocument1.docx#fullscreen&quot;</span>, <span class="comment">//定义将以全屏模式打开的文档的绝对URL。</span></span><br><span class="line">                            <span class="string">&quot;saveUrl&quot;</span>: <span class="string">&quot;https://example.com/download?doc=exampledocument1.docx&quot;</span>, <span class="comment">//定义允许将文档保存到用户个人计算机上的绝对URL。</span></span><br><span class="line">                            <span class="string">&quot;shareUrl&quot;</span>: <span class="string">&quot;https://example.com/view?doc=exampledocument1.docx&quot;</span>, <span class="comment">//定义允许其他用户共享此文档的绝对URL。</span></span><br><span class="line">                            <span class="string">&quot;toolbarDocked&quot;</span>: <span class="string">&quot;top&quot;</span> <span class="comment">//定义嵌入式查看器工具栏的位置，可以为top或bottom。</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line"></span><br><span class="line">                    <span class="string">&quot;events&quot;</span>: &#123; <span class="comment">//事件配置</span></span><br><span class="line">                        <span class="comment">// onAppReady,//-将应用程序加载到浏览器时调用的函数。</span></span><br><span class="line">                        <span class="comment">// onCollaborativeChanges //-当文档由其他用户在严格共同编辑模式下共同编辑时调用的函数。</span></span><br><span class="line">                        <span class="comment">// onDocumentReady,//-将应用程序加载到浏览器时调用的函数。</span></span><br><span class="line">                        <span class="comment">// onDocumentStateChange,//-修改文档时调用的函数。这就是所谓的使用参数：&#123;真正的“数据”&#125;在当前用户编辑文档以及与参数：&#123;“数据”：假&#125;在当前用户的更改发送到文档编辑服务。</span></span><br><span class="line">                        <span class="comment">// onDownloadAs,//-调用downloadAs方法时，使用指向已编辑文件的绝对URL调用的函数。在data参数中发送要下载的文档的绝对URL 。</span></span><br><span class="line">                        <span class="comment">// onError,//-发生错误或其他特定事件时调用的函数。错误消息在data参数中发送。</span></span><br><span class="line">                        <span class="comment">// onInfo,//-应用程序打开文件时调用的函数。该模式在data.mode参数中发送。可以查看或编辑。</span></span><br><span class="line">                        <span class="comment">// onMetaChange,//-通过meta命令更改文档的元信息时调用的函数。文档名称通过data.title参数发送。</span></span><br><span class="line">                        <span class="comment">// onOutdatedVersion,//-使用旧的document.key值打开文档进行编辑时，显示错误后调用的函数，该值用于编辑先前的文档版本并已成功保存。调用此事件时，必须使用新的document.key重新初始化编辑器。</span></span><br><span class="line">                        <span class="comment">// onReady,//-将应用程序加载到浏览器时调用的函数。自从5.0版本不推荐使用，请使用onAppReady代替</span></span><br><span class="line">                        <span class="comment">// onRequestClose,//-结束编辑器的工作并且必须关闭编辑器时调用的函数。</span></span><br><span class="line">                        <span class="comment">// onRequestCompareFile,//-用户尝试通过单击“存储中的文档”按钮来选择要比较的文档时调用的函数。要选择要比较的文档，必须调用setRevisedFile方法。如果未声明该方法，则不会显示“来自存储的文档”按钮。</span></span><br><span class="line">                        <span class="comment">// onRequestCreateNew,//-用户尝试通过单击“新建”按钮来创建文档时调用的函数。使用此方法代替createUrl字段。如果未声明该方法且未指定createUrl，则将不会显示“创建新”按钮。</span></span><br><span class="line">                        <span class="comment">// onRequestEditRights,//-用户尝试通过单击“编辑文档”按钮尝试将文档从视图切换到编辑模式时调用的函数。调用该函数时，必须在编辑模式下再次初始化编辑器。如果未声明该方法，则不会显示“编辑”按钮。</span></span><br><span class="line">                        <span class="comment">// onRequestHistory,//-用户尝试通过单击“版本历史记录”按钮显示文档版本历史记录时调用的函数。要显示文档版本历史，您必须调用refreshHistory方法。如果未声明该方法和onRequestHistoryData方法，则不会显示“版本历史记录”按钮。</span></span><br><span class="line">                        <span class="comment">// onRequestHistoryClose,//-当用户尝试通过单击“关闭历史记录”按钮来查看文档版本历史记录时，试图调用该文档时调用的函数。调用该函数时，必须在编辑模式下再次初始化编辑器。如果未声明该方法，则不会显示“关闭历史记录”按钮。</span></span><br><span class="line">                        <span class="comment">// onRequestHistoryData,//-用户尝试单击文档版本历史记录中的特定文档版本时调用的函数。</span></span><br><span class="line">                        <span class="comment">// onRequestInsertImage,//-用户尝试通过单击“保存图像”按钮插入图像时调用的函数。图像插入的类型在参数data.c中指定。</span></span><br><span class="line">                        <span class="comment">// onRequestRename,//-用户尝试通过单击“重命名...”按钮重命名文件时调用的函数。</span></span><br><span class="line">                        <span class="comment">// onRequestRestore,//-用户单击版本历史记录中的“还原”按钮来还原文件版本时调用的函数。</span></span><br><span class="line">                        <span class="comment">// onRequestSaveAs,//-用户尝试通过单击“另存为...”按钮保存文件时调用的函数。文档的标题和要下载的文档的绝对URL在data参数中发送。如果未声明该方法，则不会显示“另存为...”按钮。</span></span><br><span class="line">                        <span class="comment">// onRequestSharingSettings,//-用户单击“更改访问权限”按钮来管理文档访问权限时调用的函数。必须调用setSharingSettings方法来更新有关允许与其他用户共享文档的设置的信息。如果未声明该方法，则不会显示“更改访问权限”按钮。</span></span><br><span class="line">                        <span class="comment">// onRequestUsers,//-评论者可以选择要在评论中提及的其他用户时调用的函数。要设置用户列表，必须调用setUsers方法。</span></span><br><span class="line">                        <span class="comment">// onWarning,//-发生警告时调用的函数。警告消息在data参数中发送。</span></span><br><span class="line">                        <span class="comment">// &quot;onDocumentStateChange&quot;: function() &#123;</span></span><br><span class="line">                        <span class="comment">// &#125;, //文档改变后的回调</span></span><br><span class="line">                        <span class="comment">//&quot;onDocumentReady&quot; : onDocumentReady, //文档初始化准备好后的回调</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">var</span> docEditor = <span class="keyword">new</span> <span class="title class_">DocsAPI</span>.<span class="title class_">DocEditor</span>(<span class="string">&quot;placeholder&quot;</span>, config);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>转载至：<a href="https://blog.csdn.net/cyulotus/article/details/128404264">https://blog.csdn.net/cyulotus/article/details/128404264</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/05/06/hello-world/"/>
      <url>/2023/05/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
